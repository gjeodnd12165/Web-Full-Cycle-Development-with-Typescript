### 쿠버네티스 소개
#### 서비스 개발 및 운용 방식
- 마이크로서비스 아키텍처 (microservice architecture; MSA)
    - 응용 시스템 개발 및 구성을 위한 아키텍처 스타일의 하나
    - 이에 비교하여 전통적인 방식의 아키텍처를 모놀리식 아키텍처라고 부르기도 한다
    - 응용이 서비스 모음으로 개발되어 각 마이크로서비스는 특정한 기능을 수용하고 개별 작업을 처리, 이 서비스들이 서로 연결되어 전체 응용을 구성

#### 컨테이너 인프라 환경의 적용
- 컨테이너 모델은 마이크로서비스를 구현하기에 적합

#### 쿠버네티스란
- 줄여서 k8s 라고 표기하는 것을 자주 보게 됨
- 컨테이너 오케스트레이션 솔루션
    - 다수의 컨테이너들을 관리하면서
    - 자동 배포, 배포된 컨테이너의 동작 보증, 부하에 따른 동적 확장 등의 기능을 담당
- 도커와 잘 어울리는 실행 환경 구성 도구
    - 도커 컨테이너들을 클러스터 내에 실행하고 관리하는 데 적합
    - 지속적 통합과 인도 (CI/CD)에 유효하게 적용할 수 있음
    - 컨테이너는 포드 라고 불리는 k8s 오브젝트와 연관하여 실행 (포드 위에서 실행한다고 표현)

#### k8s 클러스터의 구성 요소
- 클러스터는 하나 이상의 노드(들)로 구성됨
- 마스터 노드 (컨트롤 플레인)
    - kubectl(반드시 마스터 노드에 있어야 하는 것은 아니지만)
    - API 서버, etcd - 클러스터의 중심 역할을 하는 구성 요소들
    - 컨트롤러 매니저, 스케줄러
- 워커 노드
    - 컨테이너 런타임 (CRI; Container Runtime Interface) - 포드를 이루는 컨테이너의 실행을 담당
    - kubelet - 포드의 구성 내용을 받아 CRI에 전달하고 컨테이너들의 동작 상태를 모니터링

#### k8s가 제공하는 기능
- 컨테이너 밸런싱 (container balancing)
    - 포드의 부하 균등화를 수행 - 몇 개의 응용을 복제할 것인지를 알려주면 나머지는 k8s가 처리
- 트래픽 로드 밸런싱 (traffic load balancing)
    - 응용의 복제본이 둘 이상 있다면 k8s 가 프래픽 부하 균등화를 수행하여 클러스터 내부에 적절히 분배
- 동적 수편 스케일링 (HPA; horizontal pod autoscaling)
    - 인스턴스 수를 동적으로 확장하거나 감축하여 동적 요구사항에 대응하면서 시스템 자원을 효율적으로 활용
- 오류 복구 (error recovery)
    - 포드와 노드를 지속적으로 모니터링하고 장애가 발생하면 새 포드를 실행하여 지정된 복제본의 수를 유지
- 롤링 업데이트 (rolling update)
    - 지연 시간을 적용하고 순차적으로 업데이트 배포함으로써 문제가 발생하더라도 서비스를 정상 유지할 수 있음
- 스토리지 오케스트레이션 (storage orchestration)
    - 원하는 응용에 다향한 스토리지 시스템 (Amazon EBS, Goggle GCE Persistent Disk 등) 을 마운트할 수 있음
- 서비스 디스커버리 (service discovery)
    - 태생적으로 수명이 짧은 포드의 동적 성질을 관리하기 위하여 자체 DNS 기반으로 서비스를 동적 바인딩할 수 있는 기능을 제공

#### k8s Pod의 생명 주기 (Life Cycle)
- kubectl 을 통해서 API 서버에 포드의 생성을 요청
    - (업데이트가 있을 때마다) API 서버는 etcd에 기록하고 클러스터의 상태를 최신으로 유지 (하려고 함)
- 컨트롤러 매니저는 포드를 생성하고, 이 상태를 API 서버에 전달
    - 아직 어떤 워커 노드에 포드를 적용할지는 결정하지 않는 상태
- 스케줄러는 포드가 생성되었다는 정보를 인지하고, 이 포드를 어떤 워커 노드에 적용할지를 결정해서 해당 노드에 포드의 실행을 요철
- 해당 노드의 kubelet 이 CRI 에 요청하여 포드가 만들어지고 사용 가능한 상태가 됨
- k8s는 절하적인 구조가 아닌 *선언적인 구조*를 가지고 있음
    - 각 요소가 추구하는 상태 (desired state) 를 선언하면 현재 상태 (current) 와 비교하고 지속적으로 맟주어 가려고 노력하는 구조

#### k8s 오브젝트들
- 기본 오브젝트
    - Pod - 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위
        - 독립적인 공간과 사용 가능한 IP를 가지고 있음, 언제든지 **죽을 수 있음**
    - Namepspace - k8s 클러스터에서 사용되는 리소스들을 구분해 관리하는 그룹
    - Volume - 포드가 생성될 떄 포드에서 사용할 수 있는 디렉토리를 제공
    - Service - 유동적인 포드들에 대한 접속을 안정적으로 유지하도록 클러스터 내/외부에 연결하는 역할
- 디플로이먼트 (Deployment)
    - 기본 오브젝트들을 보다 효율적으로 작동할 수 있도록 조합하고 추가로 구현한 것
    - 레플리카셋 (replicaset) 오브젝트를 합쳐 놓은 형태로 단순하게 생각할 수 있음

#### k8s 인프라 구축
- 로컬 환경
    - kubeadm, docker desktop 들을 설치, 운용하믕로써 로컬 환경에 간단한 클러스터 구성 가능
    - 개발 단계에서의 테스트 등에 이용
- Public clouds
    - Amazon의 AWS EKS (Elastic Kubernetes Services)
    - GCP (Google Cloud Platform) 의 GKE (Google Kubernetes Engine)
    - Microsoft 의 AKS (Azuer Kubernetes Service)
- On-prem 설치
    - SUSE 의 Rancher
    - RedHat 의 OpenShift

#### 실습 준비
- 도커 데스크톱을 이용한 로컬 환경 클러스터 구성
    - 톱니바퀴 클릭하여 설정으로 진입
    - Kubernetes - Enable Kubernetes 체크 
- 명령어
    - kubectl get nodes
- kubectl이 에러 없이 실행되는 것을 확인
- 하나의 노드에 대한 정보가 (아직은 해석하지 않지만) 표시됨을 확인

#### 요약
- Kubernetes 라는 것은 무엇이며 어떤 기능을 하는가?
    - 이것이 우리가 목표로 하고 있는 CI/CD 파이프라인의 구축과는 어떤 관계가 있을 것으로 예상하는지?: maintanance에 도움을 주는 것 같다?
- 다음에 대하여 나는 어떻게 이해하고 있는가?
    - k8s 클러스터: 하나의 서비스를 위해 이루어진 노드들의 집합
    - 노드, 포드, 컨테이너의 관계: 노드 > 포드 > 컨테이너
    - k8s 클러스터를 구축하고 운영하는 방법에는 어떠한 것들이 있으며, 이 중 우리는 어떤 것을 이용해 실습에 적용할 예정인가?: 로컬 환경, 외부 서비스, 내부 DB와의 연결 중 로컬 환경을 이용할 것